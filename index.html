<!DOCTYPE html>
<html>
<head>
  <title>Elevator Simulation</title>
  <style>
    /* ---------- 1. Theme tokens ---------- */
    :root{
      /* brand */
      --brand-h:215;
      --brand-s:80%;
      --brand-l:50%;

      /* grays */
      --gray-0:#ffffff;
      --gray-1:#f7f9fc;
      --gray-2:#e4e9f0;
      --gray-3:#cbd4e1;
      --gray-4:#9aa5b3;
      --gray-5:#4a5568;
      --gray-6:#2d3748;

      /* component radii & shadows */
      --radius-s:6px;
      --radius-m:10px;
      --shadow-s:0 1px 3px rgba(0,0,0,.08);
      --shadow-m:0 4px 10px rgba(0,0,0,.12);

      /* typography scale */
      --fs-xs:.78rem;
      --fs-s:.9rem;
      --fs-m:1rem;
      --fs-l:1.25rem;
      --fs-xl:1.6rem;

      /* animation time */
      --person-animation-time: 1.2s;
    }

    /* ---------- 2. Reset / base ---------- */
    *,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%}
    body{
      font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Helvetica,Arial,sans-serif;
      background:var(--gray-1);
      color:var(--gray-6);
      line-height:1.5;
      padding:1rem;
    }

    /* ---------- 3. Headings & helper text ---------- */
    h1{
      font-size:var(--fs-xl);
      font-weight:700;
      text-align:center;
      margin-bottom:.25rem;
    }
    .instructions{
      font-size:var(--fs-s);
      max-width:48rem;
      margin-inline:auto 1rem;
      text-align:center;
      color:var(--gray-5);
      margin-bottom:1.5rem;
    }

    /* ---------- 4. Layout wrapper ---------- */
    .container{
      max-width:72rem;
      margin-inline:auto;
      display:flex;
      flex-direction:column;
      gap:1.5rem;
    }

    /* ---------- 5. Config panel ---------- */
    .config-controls{
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(7rem,1fr));
      gap:1rem;
      background:var(--gray-0);
      padding:1rem;
      border-radius:var(--radius-m);
      box-shadow:var(--shadow-s);
    }
    .config-controls div{
      display:flex;
      flex-direction:column;
      gap:.3rem;
      text-align:center;
    }
    .config-controls label{font-size:var(--fs-xs);color:var(--gray-5)}
    .config-controls input{padding:.35rem;border:1px solid var(--gray-3);border-radius:var(--radius-s);font-size:var(--fs-s)}
    #simSpeed{width:100%}
    #simSpeedLabel{font-size:var(--fs-xs);color:var(--gray-4)}

    /* ---------- 6. CTA buttons ---------- */
    .controls{
      display:flex;
      justify-content:center;
      gap:.75rem;
    }
    .controls button{
      min-width:10rem;
      padding:.6rem 1rem;
      font-size:var(--fs-m);
      font-weight:600;
      border:none;
      border-radius:var(--radius-s);
      color:var(--gray-0);
      background:hsl(var(--brand-h) var(--brand-s) var(--brand-l));
      cursor:pointer;
      transition:filter .15s;
    }
    .controls button:hover{filter:brightness(1.05)}
    #resetBtn{background:#e11d48}
    #resetBtn:hover{filter:brightness(1.1)}

    /* ---------- 7. Global stats ---------- */
    .stats{
      display:flex;
      flex-wrap:wrap;
      justify-content:space-evenly;
      gap:1rem;
      background:var(--gray-0);
      border-radius:var(--radius-m);
      box-shadow:var(--shadow-s);
      padding:.8rem 1rem;
    }
    .stats div{font-size:var(--fs-s)}
    .stats span{font-weight:600;color:hsl(var(--brand-h) var(--brand-s) 40%)}

    /* ---------- 8. Elevator (lifter) area ---------- */
    .lifter-container{
      display:flex;
      flex-wrap:wrap;
      gap:2rem;
      justify-content:center;
      padding:1.5rem;
      background:var(--gray-0);
      border-radius:var(--radius-m);
      box-shadow:var(--shadow-s);
    }
    .lifter{
      position:relative;
      width:6rem;
      height:20rem;
      background:var(--gray-5);
      border-radius:var(--radius-s);
      box-shadow:var(--shadow-m) inset 0 0 0 2px rgba(0,0,0,.4);
    }
    .lifter-floor{
      position:absolute;
      top:.3rem;
      left:50%;
      transform:translateX(-50%);
      font-size:var(--fs-s);
      padding:.1rem .45rem;
      background:rgba(0,0,0,.6);
      border-radius:var(--radius-s);
      color:var(--gray-0);
    }
    .platform{
      position:absolute;
      left:-.6rem;
      bottom:0; /* fixed */
      width:7.2rem;
      height:1.5rem;
      background:var(--gray-3);
      border-radius:var(--radius-s);
      transition:bottom .4s ease; /* snappier */
    }
    .base{
      position:absolute;
      left:-.3rem;
      bottom:0;
      width:6.6rem;
      height:2.5rem;
      background:var(--gray-6);
      border-radius:var(--radius-m) var(--radius-m) 0 0;
    }

    /* inside each elevator */
    .lifter-passengers{
      position:absolute;
      inset:.2rem;
      display:flex;
      flex-wrap:wrap;
      justify-content:center;
      align-content:flex-end;
      gap:.2rem;
    }

    /* ---------- 9. Floor lines & labels ---------- */
    .floor-line{
      position:absolute;
      left:1rem;
      right:1rem;
      height:2px;
      background:var(--gray-4);
      border-radius:1px;
    }
    .floor-label{
      position:absolute;
      left:1.3rem;
      font-size:var(--fs-s);
      font-weight:600;
      padding:0 .4rem;
      background:var(--gray-0);
      border-radius:var(--radius-s);
      transform:translateY(50%);
    }

    /* ----------10. Stats per elevator ---------- */
    .lifter-stats{
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(14rem,1fr));
      gap:.75rem;
    }
    .lifter-stat{
      background:var(--gray-0);
      border-radius:var(--radius-s);
      box-shadow:var(--shadow-s);
      padding:.55rem .8rem;
      font-size:var(--fs-xs);
    }

    /* ----------11. Waiting + arrived areas ---------- */
    [id^="floor-waiting-"],
    [id^="arrived-area-"]{
      pointer-events:none; /* purely visual */
    }
    .person{
      width:1.1rem;
      height:1.1rem;
      font-size:var(--fs-xs);
      font-weight:700;
      display:flex;align-items:center;justify-content:center;
      border:1px solid rgba(0,0,0,.25);
      border-radius:50%;
      color:#fff;
      text-shadow:0 0 3px rgba(0,0,0,.5);
    }
    /* riding */
    .person.in-lifter{box-shadow:0 1px 3px rgba(0,0,0,.35)}
    .person.deboarding{opacity:.2;transform:translateX(.8rem) rotate(720deg)}
    .person.boarding{opacity:.65;transform:translateX(-.8rem) rotate(-720deg)}
    /* waiting state updated below with CSS variable */
    .person{
      transition:all var(--person-animation-time) cubic-bezier(.4,0,.2,1);
    }

    /* ----------12. Responsive helpers ---------- */
    @media (max-width:42rem){
      .lifter-container{gap:1rem}
      .stats{flex-direction:column;align-items:center}
    }
  </style>
</head>
<body>
  <h1>Elevator Simulation</h1>
  <div class="instructions">
    Watch how elevators operate in a building with multiple floors. People (colored dots) appear on different floors and request to go to other floors. The color of each person indicates their destination floor. Click "Start Simulation" to begin and "Reset" to clear the simulation.
  </div>
  <div class="container">
    <div class="config-controls" id="configControls">
      <div>
        <label for="numLifters">Lifters:</label>
        <input type="number" id="numLifters" value="3" min="1" max="10">
      </div>
      <div>
        <label for="numFloors">Floors:</label>
        <input type="number" id="numFloors" value="3" min="2" max="5" disabled>
      </div>
      <div>
        <label for="totalPeople">Total People:</label>
        <input type="number" id="totalPeople" value="100" min="10" max="500">
      </div>
      <div>
        <label for="spawnRate">Spawn Delay (ms):</label>
        <input type="number" id="spawnRate" value="2000" min="100" max="10000">
      </div>
      <div>
        <label for="travelTime">Floor Travel (ms):</label>
        <input type="number" id="travelTime" value="2000" min="500" max="5000">
      </div>
      <div>
        <label for="doorTime">Door Time (ms):</label>
        <input type="number" id="doorTime" value="1500" min="500" max="3000">
      </div>
      <div>
        <label for="simSpeed">Speed:</label>
        <input type="range" id="simSpeed" min="0.5" max="4" step="0.1" value="1">
        <span id="simSpeedLabel">1.0x</span>
      </div>
    </div>
    <div class="controls">
      <button id="startPauseResumeBtn">Start Simulation</button>
      <button id="resetBtn">Reset</button>
    </div>

    <div class="stats">
      <div>People Waiting: <span id="waitingCount">0</span></div>
      <div>People Transported: <span id="transportedCount">0</span></div>
      <div>Average Wait Time: <span id="avgWaitTime">0</span>s</div>
    </div>
    <div class="lifter-stats" id="lifterStats"></div>

    <div class="floor-stats" style="top: 100px">
      Floor 1: <span id="floor1Stats">0 arrived, 0 departed</span>
    </div>
    <div class="floor-stats" style="top: 180px">
      Floor 2: <span id="floor2Stats">0 arrived, 0 departed</span>
    </div>
    <div class="floor-stats" style="top: 260px">
      Floor 3: <span id="floor3Stats">0 arrived, 0 departed</span>
    </div>

    <div class="floor-line" style="bottom: 80px;"></div>
    <div class="floor-label" style="bottom: 85px; color: hsl(0, 70%, 60%);">Floor 1</div>
    <div class="floor-line" style="bottom: 160px;"></div>
    <div class="floor-label" style="bottom: 165px; color: hsl(120, 70%, 60%);">Floor 2</div>
    <div class="floor-line" style="bottom: 240px;"></div>
    <div class="floor-label" style="bottom: 245px; color: hsl(240, 70%, 60%);">Floor 3</div>

    <div class="floor-waiting" id="floor-waiting-1" style="position: absolute; bottom: 60px; right: 40px; width: 120px; height: 60px;"></div>
    <div class="floor-waiting" id="floor-waiting-2" style="position: absolute; bottom: 140px; right: 40px; width: 120px; height: 60px;"></div>
    <div class="floor-waiting" id="floor-waiting-3" style="position: absolute; bottom: 220px; right: 40px; width: 120px; height: 60px;"></div>

    <div class="lifter-container" id="lifterContainer"></div>
  </div>

    <div id="arrived-area-1" style="position: absolute; bottom: 55px; left: 40px; width: 100px; height: 25px; z-index: 90;"></div>
    <div id="arrived-area-2" style="position: absolute; bottom: 135px; left: 40px; width: 100px; height: 25px; z-index: 90;"></div>
    <div id="arrived-area-3" style="position: absolute; bottom: 215px; left: 40px; width: 100px; height: 25px; z-index: 90;"></div>
  <script>
    // Configuration (Defaults, will be read from UI)
    let NUM_LIFTERS = 3;
    let NUM_FLOORS = 3; // Note: Changing this requires CSS/HTML updates for floor lines/labels/stats
    let PERSON_SPAWN_RATE = 2000;
    let TOTAL_PEOPLE = 100;
    let BASE_FLOOR_TRAVEL_TIME = 2000;
    let BASE_DOOR_OPEN_TIME = 1500;
    let BASE_BOARDING_TIME = 1200; // Base time for boarding/deboarding animation (CSS transition is 1.2s)

    // Speed Control
    let currentSimSpeed = 1.0;
    let FLOOR_TRAVEL_TIME = BASE_FLOOR_TRAVEL_TIME;
    let DOOR_OPEN_TIME = BASE_DOOR_OPEN_TIME;
    let BOARDING_TIME = BASE_BOARDING_TIME;

    // State
    let lifters = [];
    let peopleWaiting = Array(NUM_FLOORS).fill().map(() => []);
    let peopleTransported = 0;
    let totalPeopleSpawned = 0;
    let totalWaitTime = 0;
    let simulationInterval;
    let spawnInterval;
    // Simulation Run State
    let isRunning = false;
    let isPaused = false;
    // Track arrivals from each origin floor to each destination floor
    let floorStats = Array(NUM_FLOORS).fill().map(() => ({
      arrivedFrom: Array(NUM_FLOORS).fill(0), // Count of people arrived from each floor
      departed: 0
    }));

    // Initialize lifters
    function initLifters() {
      const container = document.getElementById('lifterContainer');
      container.innerHTML = '';
      
      lifters = Array(NUM_LIFTERS).fill().map((_, i) => {
        const lifter = document.createElement('div');
        lifter.className = 'lifter';
        lifter.innerHTML = `
          <div class="lifter-floor" id="floor-indicator-${i}">${1}</div>
          <div class="platform" id="platform-${i}">
            <div class="lifter-passengers"></div>
          </div>
          <div class="base"></div>
        `;
        container.appendChild(lifter);
        
        // Set initial position to floor 1
        document.getElementById(`platform-${i}`).style.bottom = floorHeights[1] + 'px';
        
        return {
          id: i,
          element: document.getElementById(`platform-${i}`),
          passengersContainer: document.getElementById(`platform-${i}`).querySelector('.lifter-passengers'),
          currentFloor: 1,
          targetFloor: 1,
          direction: 0, // 0=idle, 1=up, -1=down
          passengers: [],
          callQueue: [], // Floors to visit
          maxCapacity: 8,
          state: 'idle', // idle, moving, doors_opening, boarding, paused
          stateTimer: 0
        };
      });
    }

    /* ---------- DYNAMIC FLOOR POSITIONS ---------- */
    const PLATFORM_HEIGHT = 24;   // .platform { height:1.5rem ≈ 24 px }
    const FLOOR_LINE_BASE = 0;   // bottom of first .floor-line (Floor 1)
    const FLOOR_GAP       = 80;   // vertical distance between floor lines

    function platformBottomFor(floor) {
      /* bottom edge sits right on the floor line, so no subtraction */
      return FLOOR_LINE_BASE + (floor - 1) * FLOOR_GAP;
    }

    const floorHeights = {};      // map: floor → platform bottom (px)
    for (let f = 1; f <= 5; f++) { // Support up to 5 floors as per UI max
      floorHeights[f] = platformBottomFor(f);
    }

    // Move lifter to floor
    function moveLifter(lifter, floor) {
      if (floor > lifter.currentFloor) {
        lifter.direction = 1;
      } else if (floor < lifter.currentFloor) {
        lifter.direction = -1;
      } else {
        lifter.direction = 0;
      }
      lifter.state = 'moving';
      updateLifterVisualState(lifter); // Update visual cues
      lifter.targetFloor = floor;
      lifter.element.style.bottom = floorHeights[floor] + 'px';
      
      // Update floor indicator to show transition
      if (floor !== lifter.currentFloor) {
        document.getElementById(`floor-indicator-${lifter.id}`).textContent = `${lifter.currentFloor}->${floor}`;
      }
      
      // Calculate travel time based on number of floors
      const floorsToTravel = Math.abs(floor - lifter.currentFloor);
      const travelTime = floorsToTravel * (FLOOR_TRAVEL_TIME / currentSimSpeed);
      
      lifter.stateTimer = setTimeout(() => {
        if (isPaused) { lifter.state = 'paused'; return; } // Handle pause during travel
        lifter.currentFloor = floor;
        // Update floor indicator to show final floor
        document.getElementById(`floor-indicator-${lifter.id}`).textContent = floor;
        lifter.direction = 0;
        lifter.state = 'doors_opening';
        updateLifterVisualState(lifter);
        lifter.stateTimer = setTimeout(() => {
          if (isPaused) { lifter.state = 'paused'; return; } // Handle pause during door open
          lifter.state = 'boarding';
          updateLifterVisualState(lifter);
          processBoarding(lifter);
        }, DOOR_OPEN_TIME / currentSimSpeed);
      }, travelTime);
    }

    // Handle boarding and deboarding with animations
    function processBoarding(lifter) {
      // First deboard passengers for current floor only
      const deboarding = lifter.passengers.filter(p => p.destinationFloor === lifter.currentFloor);
      let deboardIndex = 0;
      let boardIndex = 0;
      const floorQueue = peopleWaiting[lifter.currentFloor - 1];
      const boarding = [];

      // Log for debugging
      console.log(`Processing boarding at floor ${lifter.currentFloor}, passengers to deboard: ${deboarding.length}, total passengers: ${lifter.passengers.length}`);

      // Prepare boarding list
      while (floorQueue.length > 0 && lifter.passengers.length - deboarding.length < lifter.maxCapacity) {
        const person = floorQueue.shift();
        const personDirection = person.destinationFloor > lifter.currentFloor ? 1 : -1;
        if (lifter.direction === 0 || lifter.direction === personDirection || lifter.callQueue.length === 0) {
          boarding.push(person);
          if (lifter.direction === 0) {
            lifter.direction = personDirection;
          }
        } else {
          floorQueue.push(person);
          break;
        }
      }

      // Function to handle deboarding animation one by one
      function animateDeboarding() {
        if (deboardIndex < deboarding.length) {
          const p = deboarding[deboardIndex];
          // Double-check that we're only deboarding at the correct floor
          if (p.destinationFloor !== lifter.currentFloor) {
            console.error("Error: Attempting to deboard passenger at wrong floor", p, lifter);
            deboardIndex++;
            animateDeboarding();
            return;
          }
          const waitTime = Date.now() - p.waitStart;
          totalWaitTime += waitTime;
          p.element.classList.add('deboarding');
          console.log(`Deboarding person from floor ${p.startFloor} to ${p.destinationFloor} at lifter floor ${lifter.currentFloor}`);
          setTimeout(() => {
            if (isPaused) return; // Don't complete animation if paused
            p.element.classList.remove('deboarding');
            p.element.style.position = 'absolute';
            const arrivedArea = document.getElementById(`arrived-area-${p.destinationFloor}`);
            arrivedArea.appendChild(p.element); // Move to arrived area
            // Simple positioning in arrived area
            const arrivedCount = arrivedArea.childElementCount - 1;
            const col = arrivedCount % 5;
            p.element.style.left = `${10 + col * 18}px`;
            p.element.style.bottom = `2px`;
            setTimeout(() => p.element.remove(), 2000);
            peopleTransported++;
            floorStats[p.destinationFloor - 1].arrivedFrom[p.startFloor - 1]++;
            updateStats();
            updateFloorStats();
            updateLifterStats(); // Update passenger count
            deboardIndex++;
            animateDeboarding();
          }, BASE_BOARDING_TIME); // Use base time for visual disappearance
        } else {
          lifter.passengers = lifter.passengers.filter(p => p.destinationFloor !== lifter.currentFloor);
          updatePassengerPositions(lifter);
          animateBoarding();
        }
      }

      // Function to handle boarding animation one by one
      function animateBoarding() {
        if (boardIndex < boarding.length) {
          const person = boarding[boardIndex];
          person.element.classList.add('boarding');
          setTimeout(() => {
            if (isPaused) return; // Don't complete animation if paused
            person.element.classList.remove('boarding');
            person.boardLifter(lifter);
            updateLifterStats(); // Update passenger count
            boardIndex++;
            animateBoarding();
          }, BOARDING_TIME / currentSimSpeed);
        } else {
          lifter.state = 'idle';
          determineNextAction(lifter);
        }
      }

      // Start the animation sequence
      if (deboarding.length > 0) {
        animateDeboarding();
      } else if (boarding.length > 0) {
        animateBoarding();
      } else {
        lifter.stateTimer = setTimeout(() => {
          if (isPaused) { lifter.state = 'paused'; return; } // Handle pause during door close
          lifter.state = 'idle';
          determineNextAction(lifter);
        }, DOOR_OPEN_TIME / currentSimSpeed);
      }
    }

    // Determine next action for elevator
    function determineNextAction(lifter) {
      if (isPaused || lifter.state !== 'idle') return; // Don't act if paused or already busy
      // Clear any existing timer
      if (lifter.stateTimer) {
        clearTimeout(lifter.stateTimer);
        lifter.stateTimer = 0;
      }
      
      // If there are passengers, go to their destinations
      if (lifter.passengers.length > 0) {
        // Group destinations by floor
        const destinations = [...new Set(lifter.passengers.map(p => p.destinationFloor))];
        // Sort based on current direction
        if (lifter.direction === 1) {
          destinations.sort((a, b) => a - b);
        } else if (lifter.direction === -1) {
          destinations.sort((a, b) => b - a);
        } else {
          // If no direction, choose closest
          destinations.sort((a, b) => Math.abs(a - lifter.currentFloor) - Math.abs(b - lifter.currentFloor));
          lifter.direction = destinations[0] > lifter.currentFloor ? 1 : -1;
        }
        lifter.callQueue = destinations;
        moveLifter(lifter, destinations[0]);
        return;
      }
      
      // Check call queue
      if (lifter.callQueue.length > 0) {
        const nextFloor = lifter.callQueue.shift();
        moveLifter(lifter, nextFloor);
        return;
      }
      
      // No passengers, no calls - look for waiting people
      const floorsWithWaiting = [];
      for (let i = 0; i < NUM_FLOORS; i++) {
        if (peopleWaiting[i].length > 0) {
          floorsWithWaiting.push({
            floor: i + 1,
            count: peopleWaiting[i].length,
            distance: Math.abs((i + 1) - lifter.currentFloor),
            waitTime: peopleWaiting[i].length > 0 ? Date.now() - peopleWaiting[i][0].waitStart : 0
          });
        }
      }
      
      if (floorsWithWaiting.length > 0) {
        // Sort by a combination of wait time and distance
        floorsWithWaiting.sort((a, b) => (b.waitTime * 0.6 + b.count * 0.4) - (a.waitTime * 0.6 + a.count * 0.4));
        const targetFloor = floorsWithWaiting[0].floor;
        lifter.callQueue = [targetFloor];
        moveLifter(lifter, targetFloor);
        return;
      }
      
      // If nothing to do, return to ground floor or stay put
      lifter.direction = 0;
      if (lifter.currentFloor !== 1) {
        moveLifter(lifter, 1);
      }
    }

    // Person class
    class Person {
      constructor() {
        this.startFloor = Math.floor(Math.random() * NUM_FLOORS) + 1;
        let destinationFloor = this.startFloor;
        while (destinationFloor === this.startFloor) {
          destinationFloor = Math.floor(Math.random() * NUM_FLOORS) + 1;
        }
        this.destinationFloor = destinationFloor;
        this.waitStart = Date.now();
        this.element = document.createElement('div');
        this.element.className = 'person waiting';
        // Set color based on destination floor
        const colors = {
          1: 'hsl(0, 70%, 60%)',   // Red for Floor 1
          2: 'hsl(120, 70%, 60%)', // Green for Floor 2
          3: 'hsl(240, 70%, 60%)'  // Blue for Floor 3
        };
        this.element.style.backgroundColor = colors[this.destinationFloor];
        this.element.style.zIndex = '100';
        // Add destination floor number inside the circle
        this.element.textContent = this.destinationFloor;
      }

      boardLifter(lifter) {
        this.element.classList.remove('waiting');
        this.element.classList.add('in-lifter');
        lifter.passengersContainer.appendChild(this.element);
        lifter.passengers.push(this);
        updatePassengerPositions(lifter);
      }
    }

    function updatePassengerPositions(lifter) {
      lifter.passengers.forEach((p, index) => {
        const col = index % 5;
        p.element.style.left = `${col * 20}px`;
        p.element.style.bottom = `2px`;
        p.element.style.zIndex = 10;
      });
    }

    // Spawn people
    function spawnPeople() {
      if (isPaused || totalPeopleSpawned >= TOTAL_PEOPLE) {
        // If paused, just return. If finished spawning, clear interval.
        if (totalPeopleSpawned >= TOTAL_PEOPLE) {
          clearInterval(spawnInterval);
        }
        return;
      }
      
      const person = new Person();
      peopleWaiting[person.startFloor - 1].push(person);
      // Add to the waiting area for the specific floor
      const floorWaitingArea = document.getElementById(`floor-waiting-${person.startFloor}`);
      floorWaitingArea.appendChild(person.element);
      // Position in grid layout within the waiting area
      const index = floorWaitingArea.childElementCount - 1;
      const row = Math.floor(index / 6); // Adjusted for better spacing
      const col = index % 6;
      person.element.style.left = `${10 + col * 18}px`; // Adjusted for better spacing
      person.element.style.bottom = `${10 + row * 18}px`; // Position relative to waiting area bottom
      floorStats[person.startFloor - 1].departed++;
      totalPeopleSpawned++;
      updateFloorStats();
      updateStats();
      updateLifterStats();
    }

    // Main simulation loop
    function runSimulation() {
      if (isPaused) return;
      // Check on lifters that are idle and might need new actions
      lifters.forEach(lifter => {
        updateLifterStats(); // Keep stats updated
        if (lifter.state === 'idle' && lifter.callQueue.length === 0 && lifter.passengers.length === 0) {
          determineNextAction(lifter);
        }
      });
    }

    // Update statistics
    function updateLifterStats() {
      const container = document.getElementById('lifterStats');
      container.innerHTML = '';
      
      lifters.forEach((lifter, i) => {
        const stat = document.createElement('div');
        stat.className = 'lifter-stat';
        const dir = lifter.direction === 1 ? '↑' : lifter.direction === -1 ? '↓' : '-';
        let stateText = lifter.state;
        if (lifter.state === 'moving') {
          stateText += ` (${lifter.currentFloor}->${lifter.targetFloor})`;
        }
        stat.textContent = `Lifter ${i+1}: F${lifter.currentFloor}, P: ${lifter.passengers.length}/${lifter.maxCapacity}, Dir: ${dir}, State: ${stateText}`;
        container.appendChild(stat);
      });
    }

    function updateStats() {
      const totalWaiting = peopleWaiting.reduce((sum, queue) => sum + queue.length, 0);
      document.getElementById('waitingCount').textContent = totalWaiting;
      document.getElementById('transportedCount').textContent = peopleTransported;
      const avgWaitTime = peopleTransported > 0 ? (totalWaitTime / peopleTransported / 1000).toFixed(1) : 0;
      document.getElementById('avgWaitTime').textContent = avgWaitTime;
    }

    function updateFloorStats() {
      const colors = {
        1: 'hsl(0, 70%, 60%)',   // Red for Floor 1
        2: 'hsl(120, 70%, 60%)', // Green for Floor 2
        3: 'hsl(240, 70%, 60%)'  // Blue for Floor 3
      };
      
      for (let i = 0; i < NUM_FLOORS; i++) {
        const arrivedDetails = floorStats[i].arrivedFrom
          .map((count, originFloor) => {
            if (count > 0) {
              const floorNum = originFloor + 1;
              return `<span style="color: ${colors[floorNum]}">${count} from F${floorNum}</span>`;
            }
            return '';
          })
          .filter(text => text !== '')
          .join(', ');
          
        document.getElementById(`floor${i+1}Stats`).innerHTML = 
          `Arrived: ${arrivedDetails || '0'}, Departed: ${floorStats[i].departed}`;
      }
    }

    // Update Simulation Speed and Apply Changes
    function updateSimulationSpeed() {
      const speedSlider = document.getElementById('simSpeed');
      currentSimSpeed = parseFloat(speedSlider.value);
      document.getElementById('simSpeedLabel').textContent = `${currentSimSpeed.toFixed(1)}x`;

      // Update time constants based on speed (used for setTimeout durations)
      FLOOR_TRAVEL_TIME = BASE_FLOOR_TRAVEL_TIME / currentSimSpeed;
      DOOR_OPEN_TIME = BASE_DOOR_OPEN_TIME / currentSimSpeed;
      BOARDING_TIME = BASE_BOARDING_TIME / currentSimSpeed; // Affects boarding step duration

      // Update CSS variable for animation durations (affecting CSS transitions)
      const personAnimationTime = (BASE_BOARDING_TIME / currentSimSpeed / 1000).toFixed(2); // Convert ms to s for CSS
      document.documentElement.style.setProperty('--person-animation-time', `${personAnimationTime}s`);

      // If simulation is running and not paused, restart spawn interval with new rate
      if (isRunning && !isPaused) {
        clearInterval(spawnInterval);
        // Ensure spawn rate doesn't become too fast
        const adjustedSpawnRate = Math.max(50, PERSON_SPAWN_RATE / currentSimSpeed);
         spawnInterval = setInterval(spawnPeople, adjustedSpawnRate);
      }
    }

    // Start Simulation - Reads config, resets state, starts intervals
    function startSimulation() {
      if (isRunning) return; // Already running

      // Read config values from UI just before starting
      NUM_LIFTERS = parseInt(document.getElementById('numLifters').value);
      // NUM_FLOORS = parseInt(document.getElementById('numFloors').value); // Requires more work if enabled
      TOTAL_PEOPLE = parseInt(document.getElementById('totalPeople').value);
      PERSON_SPAWN_RATE = parseInt(document.getElementById('spawnRate').value);
      BASE_FLOOR_TRAVEL_TIME = parseInt(document.getElementById('travelTime').value);
      BASE_DOOR_OPEN_TIME = parseInt(document.getElementById('doorTime').value);
      // BASE_BOARDING_TIME is fixed for animation for now

      isRunning = true;
      isPaused = false;
      resetSimulationState(); // Reset state but keep config values/UI enabled state
      updateSimulationSpeed(); // Apply initial speed setting from slider
      // Ensure spawn rate doesn't become too fast
      const initialSpawnRate = Math.max(50, PERSON_SPAWN_RATE / currentSimSpeed);
      spawnInterval = setInterval(spawnPeople, initialSpawnRate);
      simulationInterval = setInterval(runSimulation, 100); // Main logic check frequency

      document.getElementById('startPauseResumeBtn').textContent = 'Pause';
      // Disable config inputs during simulation
      document.querySelectorAll('#configControls input').forEach(input => input.disabled = true);
    }

    // Reset Simulation State (internal helper)
    function resetSimulationState() {
        clearInterval(simulationInterval);
        clearInterval(spawnInterval);
        lifters.forEach(lifter => {
            if (lifter.stateTimer) {
                clearTimeout(lifter.stateTimer);
            }
            // Clear any people elements still visually in lifters
             if (lifter.passengersContainer) {
                 lifter.passengersContainer.innerHTML = '';
             }
        });
        initLifters(); // Recreate lifter objects and elements
        peopleWaiting = Array(NUM_FLOORS).fill().map(() => []);
        peopleTransported = 0;
        totalPeopleSpawned = 0;
        totalWaitTime = 0;
        floorStats = Array(NUM_FLOORS).fill().map(() => ({
            arrivedFrom: Array(NUM_FLOORS).fill(0),
            departed: 0
        }));
        updateStats();
        // Clear waiting and arrived areas visually
        document.querySelectorAll('.floor-waiting, [id^="arrived-area-"]').forEach(el => el.innerHTML = '');
        updateFloorStats();
        updateLifterStats();
    }

    // Reset Simulation (called by button) - Clears state and resets UI
    function resetSimulation() {
        resetSimulationState(); // Clear all simulation state

        isRunning = false;
        isPaused = false;
        document.getElementById('startPauseResumeBtn').textContent = 'Start Simulation';
        // Re-enable config inputs (except floors)
        document.querySelectorAll('#configControls input:not(#numFloors)').forEach(input => input.disabled = false);
        // Also re-enable speed slider if it was disabled
        document.getElementById('simSpeed').disabled = false;
    }

    // Toggle Pause/Resume State
    function togglePauseResume() {
      if (!isRunning) return; // Can't pause if not running

      isPaused = !isPaused;
      if (isPaused) {
        document.getElementById('startPauseResumeBtn').textContent = 'Resume';
        clearInterval(spawnInterval); // Stop spawning
        // Existing timeouts will complete unless checked internally. Main loop stops.
        // Mark lifter state visually if desired (e.g., change color) - Optional
      } else {
        document.getElementById('startPauseResumeBtn').textContent = 'Pause';
        // Restart spawning if not finished
        if (totalPeopleSpawned < TOTAL_PEOPLE) {
           // Ensure spawn rate doesn't become too fast
           const adjustedSpawnRate = Math.max(50, PERSON_SPAWN_RATE / currentSimSpeed);
           spawnInterval = setInterval(spawnPeople, adjustedSpawnRate);
        }
        // Lifters paused mid-action might need a nudge if their timeout check logic isn't robust.
        // Setting them back to 'idle' if they were 'paused' state allows determineNextAction to reconsider them.
        lifters.forEach(lifter => {
            if (lifter.state === 'paused') { // If we marked them as paused explicitly
                lifter.state = 'idle';
                // Optionally, immediately check if they should do something
                // determineNextAction(lifter);
            }
        });
        // The main runSimulation interval will restart checks.
      }
      updateLifterStats(); // Update display to show paused state if implemented visually
    }

    // Helper function for visual state (optional enhancement)
    function updateLifterVisualState(lifter) {
        // Example: Remove previous state classes
        // lifter.element.classList.remove('moving', 'doors-open', 'idle');
        // Add current state class
        // if (lifter.state === 'moving') lifter.element.classList.add('moving');
        // Add more logic here later to change border colors, icons, etc.
    }

    // Event listeners
    document.getElementById('startPauseResumeBtn').addEventListener('click', () => {
      if (!isRunning) {
        startSimulation();
      } else {
        togglePauseResume();
      }
    });
    document.getElementById('resetBtn').addEventListener('click', resetSimulation);
    document.getElementById('simSpeed').addEventListener('input', updateSimulationSpeed); // Listener for speed slider

    // Initialize
    initLifters();
    updateLifterStats(); // Initial update
  </script>
</body>
</html>
